# EstÃ¡ndar Personalizado de Testing - Ejemplo

Este archivo demuestra cÃ³mo crear un estÃ¡ndar personalizado para tu equipo.

## ğŸ“‹ Convenciones de Nombres

### Tests
- Los tests deben seguir el patrÃ³n: `should <acciÃ³n> when <condiciÃ³n>`
- Usar nombres descriptivos en inglÃ©s
- Evitar abreviaciones no estÃ¡ndar

**Ejemplos:**
```dart
test('should return user data when repository call succeeds', () {});
test('should throw exception when user is not found', () {});
```

### Variables de Test
- Mocks: prefijo `mock` (ej: `mockUserRepository`)
- Fakes: prefijo `fake` (ej: `fakeUser`)
- Stubs: prefijo `stub` (ej: `stubResponse`)

## ğŸ¯ Cobertura Requerida

### MÃ­nimos por Tipo
- **Repositorios** (via Middlewares): 90%
- **Middlewares**: 85%
- **Widgets**: 75%
- **Utilities**: 95%

### Casos Obligatorios
Todo componente debe testear:
1. âœ… **Happy path** (escenario exitoso)
2. âœ… **Error handling** (manejo de errores)
3. âœ… **Edge cases** (casos lÃ­mite)
4. âœ… **Null safety** (valores nulos)

## ğŸ”§ ConfiguraciÃ³n de Mocks

### Usar Mockito con @GenerateNiceMocks
```dart
import 'package:mockito/annotations.dart';

@GenerateNiceMocks([
  MockSpec<UserRepository>(),
  MockSpec<Store<AppState>>(),
])
void main() {}
```

### UbicaciÃ³n Centralizada
- âŒ **NO** crear archivos `.mocks.dart` en cada carpeta de test
- âœ… **SÃ** usar `test/mocks/mocks.dart` centralizado

## ğŸ§ª Estructura de Tests

### Setup y Teardown
```dart
group('FeatureMiddleware', () {
  late MockRepository mockRepo;
  late FeatureMiddleware middleware;

  setUp(() {
    mockRepo = MockRepository();
    middleware = FeatureMiddleware(repository: mockRepo);
  });

  tearDown(() {
    // Limpiar recursos si es necesario
  });

  test('should...', () {});
});
```

### OrganizaciÃ³n con Groups
- Usar `group` para agrupar tests relacionados
- MÃ¡ximo 3 niveles de anidaciÃ³n
- Nombres de grupos descriptivos

```dart
group('UserMiddleware', () {
  group('FetchUser', () {
    test('should dispatch success when user found', () {});
    test('should dispatch error when user not found', () {});
  });
  
  group('UpdateUser', () {
    test('should dispatch success when update succeeds', () {});
  });
});
```

## ğŸ¨ Builders y Test Data

### Uso de Builders
- Crear builders para modelos complejos
- Ubicar en `test/builders/`
- Seguir patrÃ³n `withX` + `build()`

**Ejemplo:**
```dart
class UserBuilder {
  String _name = 'John Doe';
  int _age = 30;

  UserBuilder withName(String name) {
    _name = name;
    return this;
  }

  UserBuilder withAge(int age) {
    _age = age;
    return this;
  }

  User build() => User(name: _name, age: _age);
}

// Uso en tests
final user = UserBuilder()
  .withName('Jane')
  .withAge(25)
  .build();
```

## ğŸ” Verificaciones EspecÃ­ficas

### Middlewares
- Usar `verifyInOrder` para secuencias de dispatches
- Siempre terminar con `verifyNoMoreInteractions`

```dart
test('should follow correct dispatch sequence', () {
  // Arrange
  when(mockRepo.fetch()).thenAnswer((_) async => right(data));

  // Act
  middleware.run(mockStore, action, next);

  // Assert
  verifyInOrder([
    mockStore.dispatch(SetLoadingAction(true)),
    mockRepo.fetch(),
    mockStore.dispatch(SetDataAction(data)),
    mockStore.dispatch(SetLoadingAction(false)),
  ]);
  verifyNoMoreInteractions(mockRepo);
});
```

### Widgets
- Limpiar interacciones despuÃ©s de `pumpAndSettle` si el widget dispara acciones en `onInit`
- Verificar renders y callbacks

```dart
testWidgets('should render correctly', (tester) async {
  await tester.pumpWidget(createTestWidget());
  await tester.pumpAndSettle();
  
  clearInteractions(mockStore); // Limpiar acciones de init
  
  expect(find.text('Hello'), findsOneWidget);
  
  await tester.tap(find.byType(ElevatedButton));
  await tester.pumpAndSettle();
  
  verify(mockStore.dispatch(any)).called(1);
});
```

## ğŸ“Š Mejores PrÃ¡cticas Adicionales

### Performance
- Evitar tests que dependan de timeouts largos
- Usar `pumpAndSettle` en lugar de mÃºltiples `pump`
- No usar `Future.delayed` en tests

### Legibilidad
- MÃ¡ximo 20 lÃ­neas por test (excluir setup)
- Comentar solo escenarios complejos
- Preferir nombres descriptivos sobre comentarios

### Mantenibilidad
- Un test debe fallar por una sola razÃ³n
- Tests independientes (no compartir estado)
- Evitar lÃ³gica condicional en tests

## ğŸš« Anti-Patrones a Evitar

âŒ **Tests que no fallan nunca**
```dart
test('should work', () {
  // CÃ³digo que hace cosas pero no verifica nada
});
```

âŒ **Tests acoplados**
```dart
test('test A', () {
  globalState.value = 42; // Mal: afecta otros tests
});
```

âŒ **Tests con mÃºltiples asserts no relacionados**
```dart
test('should do everything', () {
  expect(a, 1);
  expect(b, 2);
  expect(c, 3); // Cada assert deberÃ­a ser un test separado
});
```

## âœ… Checklist Pre-Commit

Antes de hacer commit, verificar:

- [ ] Todos los tests pasan localmente
- [ ] Cobertura cumple con mÃ­nimos requeridos
- [ ] No hay `.mocks.dart` dispersos (solo en `test/mocks/`)
- [ ] Nombres de tests siguen el patrÃ³n `should...when...`
- [ ] Tests son independientes y reproducibles
- [ ] No hay cÃ³digo comentado o `skip` sin justificaciÃ³n
- [ ] Builders existen para modelos complejos usados en mÃºltiples tests

---

## ğŸ“– Referencias

- [DocumentaciÃ³n Oficial de Flutter Testing](https://docs.flutter.dev/testing)
- [Mockito Documentation](https://pub.dev/packages/mockito)
- [Testing Best Practices - Dart](https://dart.dev/guides/testing)
